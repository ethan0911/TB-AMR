
#include "ospray/math/box.ih"
#include "ospray/math/vec.ih"
#include "ospray/volume/Volume.ih"

#include "volume/Volume.ih"
#include "VoxelOctree.ih"
#include "FindCell.ih"
#include "FindDualCell.ih"

// const uniform float delta = 0.01f;


inline float max(float a, float b, float c)
{
  return max(max(a,b),c);
}

inline float min(float a, float b, float c)
{
   return min(min(a,b),c);
}

inline float max(float a, float b, float c, float d,
                 float e, float f, float g, float h)
{
  return max(max(max(a,b),max(c,d)),max(max(e,f),max(g,h)));
}

inline float min(float a, float b, float c, float d,
                 float e, float f, float g, float h)
{
  return min(min(min(a,b),min(c,d)),min(min(e,f),min(g,h)));
}


// Our ISPC side version of the struct, with pointers back into data
// shared with the C++ side

struct TAMRVolume {
  // The "parent" class
  Volume super;

  // void *uniform p4estTree;
  // Note: ISPC only supports 32-bit addressing, so if we are above
  // this number of bytes (highly likely for large data!) we'll need
  // to do the two-phase thing Ingo describes in
  // https://ingowald.blog/2018/06/13/ispc-bag-of-tricks-part-1-addressing/
  // which is used throughout OSPRay as well
  // uniform uint64 p4estTreeBytes;

  //SCALAR SAMPLING
  //! pointer to the c++-side object (since we do everything scalar for now)
  void *cppObject;
  //! pointer to a c++-side sampler object (maintained on cpp side
  void *cppSampler;

  //! Grid dimension.
  uniform vec3i dimensions;
  //! Grid origin.
  uniform vec3f gridOrigin;
  //! Grid spacing in each dimension in world coordinate.
  uniform vec3f gridWorldSpace; 
  //! Grid origin in worldspace.
  uniform vec3f worldOrigin;

  uniform VoxelOctree _voxelAccel; 

    //! Transform from local coordinates to world coordinates using the volume's grid definition.
  void (*uniform transformLocalToWorld)(const TAMRVolume *uniform volume,
                                        const varying vec3f &localCoord,
                                        varying vec3f &worldCoord);

  //! Transform from world coordinates to local coordinates using the volume's grid definition.
  void (*uniform transformWorldToLocal)(const TAMRVolume *uniform volume,
                                        const varying vec3f &worldCoord,
                                        varying vec3f &localCoord);
};


/************************************************************
 *  Octant method interpolation
 ***********************************************************/
struct Octant {
  // -------------------------------------------------------
  /* input parameters that specify the cell. coords must be the actual
     cell centers on the desired level */
  // vec3f centerPos;
  vec3f signs;
  vec3i mirror;
  bool left_x, left_y, left_z;

  // position of cell-center that spans this octant
  vec3f center;
  // position of cell-vertex that spans other extreme of this octant
  vec3f vertex;

  //! interpolation weights
  vec3f weights; // weight for C000 being at the CELL CENTER, and C111 being the CELL CORNER
  // -------------------------------------------------------
  /* values as found the by the query. C000 is always the CELL CENTER, and C111 the CELL CORNER */
  // the respective level (width) we require for the respective i'th octant corner
  float cornerWidth[8];
  float value[8];
};

inline float lerp(const Octant &O)
{
  const vec3f &w = O.weights;
  const float f000 = O.value[C000];
  const float f001 = O.value[C001];
  const float f010 = O.value[C010];
  const float f011 = O.value[C011];
  const float f100 = O.value[C100];
  const float f101 = O.value[C101];
  const float f110 = O.value[C110];
  const float f111 = O.value[C111];

  const float f00 = (1.f-w.x)*f000 + w.x*f001;
  const float f01 = (1.f-w.x)*f010 + w.x*f011;
  const float f10 = (1.f-w.x)*f100 + w.x*f101;
  const float f11 = (1.f-w.x)*f110 + w.x*f111;

  const float f0 = (1.f-w.y)*f00+w.y*f01;
  const float f1 = (1.f-w.y)*f10+w.y*f11;

  const float f = (1.f-w.z)*f0+w.z*f1;
  return f;
}

inline bool isCoarser(const float width, const CellRef &C)
{
  return width > C.width;
}

inline void initOctantAndDual(Octant &O, DualCell &D, const vec3f &P, const CellRef &C)
{
  const float cellWidth = C.width;
  const float halfCellWidth = cellWidth * 0.5f;
  const float rcpCellWidth  = rcp(cellWidth);
  const vec3f xfmed = (P-halfCellWidth)*rcpCellWidth;
  const vec3f f_idx = floor(xfmed);
  D.pos   = f_idx * cellWidth + halfCellWidth;

  // correction due to apparent rounding errors. in some rare cases
  // where the point is exactly ON the right-side bounding plane we
  // compute the lower-side dual cell rather than the right-side dual
  // cell, and that confuses a few things below
  if ((P.x - D.pos.x) > C.width) D.pos.x += C.width;
  if ((P.y - D.pos.y) > C.width) D.pos.y += C.width;
  if ((P.z - D.pos.z) > C.width) D.pos.z += C.width;

  D.width = cellWidth;

  const vec3f CC = centerOf(C);
  O.left_x = P.x <= CC.x;
  O.left_y = P.y <= CC.y;
  O.left_z = P.z <= CC.z;
  O.mirror.x = O.left_x ? 1 : 0;
  O.mirror.y = O.left_y ? 1 : 0;
  O.mirror.z = O.left_z ? 1 : 0;

  O.signs = make_vec3f(O.left_x ? -1.f : +1.f,
                       O.left_y ? -1.f : +1.f,
                       O.left_z ? -1.f : +1.f);

  vec3f weight = xfmed - f_idx;
  D.weights = make_vec3f(O.mirror.x ? (1 - weight.x) : weight.x,
                        O.mirror.y ? (1 - weight.y) : weight.y,
                        O.mirror.z ? (1 - weight.z) : weight.z);

  O.center = CC;
  O.vertex = O.center + O.signs * halfCellWidth;

  O.weights = abs(P - O.center) * (2.f * rcpCellWidth);
}

//! hats from leaves only on current level
inline float coarseBoundaryValue(const uniform TAMRVolume *uniform self,
                                 const vec3f &P,
                                 const float currentWidth)
{
  DualCell D;
  initDualCell(D,P,currentWidth);
  findDualCell(self->_voxelAccel,D);

  return lerp(D);
}



/************************************************************
 *  Octant Method. Coarser side stich : LUT_Trilinear
 *  !!!! buggy if I put the code below in filter_linear.ispc
 ***********************************************************/
enum VERTEXTOPO {IDENTIFY=0, EDGE, FACEDIAG, DIAG};

inline VERTEXTOPO GetVtxTopo(varying unsigned int8 idx1,
                             varying unsigned int8 idx2)
{
  VERTEXTOPO vtxTopo = IDENTIFY;
  unsigned int8 topo = idx1 ^ idx2;
  // same vertex
  if (topo == 0)
    vtxTopo = IDENTIFY;
  // edge p1_idx ^ p2_idx == 1,2,4
  if (topo == 1 || topo == 2 || topo == 4)
    vtxTopo = EDGE;
  // face diag p1_idx ^ p2_idx == 3,5,6
  if (topo == 3 || topo == 5 || topo == 6)
    vtxTopo = FACEDIAG;
  // diag p1_idx ^ p2_idx == 7
  if (topo == 7)
    vtxTopo = DIAG;

  return vtxTopo;
}


inline unsigned int8 modIdx(unsigned int8 a, unsigned int8 b){
  return (a < b) ? a : a - b;
}

//! transform a vertex index in octant coordinate system to a finner point
//! coordinate system
inline varying unsigned int8 Oct2FinerCoord(varying unsigned int8 whichFiner,
                                            varying unsigned int8 index)
{
  unsigned int8 res = index;
  if (whichFiner & 1)
    res ^= 1;
  if (whichFiner & 2)
    res ^= 2;
  if (whichFiner & 4)
    res ^= 4;
  return res;
}


inline varying float stitchCoarserVertex(const uniform TAMRVolume *uniform self,
                                  const CellRef &C,
                                  const varying Octant &O,
                                  const varying DualCell &D,
                                  const varying vec3f &P)
{
  float ctrlPntsValue[8];
  float weights[8];
  float wSum            = 0;
  unsigned int8 numFinerNeighbors = 0;
  unsigned int8 finerPntIdx[8];
  // count how many neighbors are in the same level of current dual cell
  unsigned int8 numCoarseCtrlPnt = 0;
  unsigned int8 coarsePntIdx[8];

  const float delta = 0.01f;

  // print("pos:[%,%,%]\n",P.x, P.y, P.z);

  for (uniform unsigned int i = 0; i < 8; i++) {
    ctrlPntsValue[i] = D.value[i];
    if (D.actualWidth[i] < D.width) {
      finerPntIdx[numFinerNeighbors++] = i;
    }else{
      coarsePntIdx[numCoarseCtrlPnt++] = i;
    }
  }

  unsigned int8 lastFiner = finerPntIdx[numFinerNeighbors - 1];

  vec3f deltP = O.vertex + delta * C.width *
                     make_vec3f(((lastFiner & 1) ? 1.f : -1.f) * O.signs.x,
                                ((lastFiner & 2) ? 1.f : -1.f) * O.signs.y,
                                ((lastFiner & 4) ? 1.f : -1.f) * O.signs.z);

  CellRef cell = findLeafCell(self->_voxelAccel, deltP);
  Octant OP;
  DualCell DP;
  initOctantAndDual(OP, DP, deltP, cell);
  findMirroredDualCell(self->_voxelAccel, OP.mirror, DP);

  for (unsigned int i = 0; i < numFinerNeighbors; i++) {
    ctrlPntsValue[finerPntIdx[i]] =
        DP.value[Oct2FinerCoord(lastFiner, finerPntIdx[i])];
  }
  
  // one neighbor are finer
  if(numFinerNeighbors == 1){
    for (unsigned int8 i = 0; i < 8; i++) {
      VERTEXTOPO vtxTopo = GetVtxTopo(finerPntIdx[0],i);
      if(vtxTopo == IDENTIFY) weights[i] = 8.f / 27.f;
      if(vtxTopo == EDGE) weights[i] = 1.f / 12.f;
      if(vtxTopo == FACEDIAG) weights[i] = 1.f / 9.f;
      if(vtxTopo == DIAG) weights[i] = 13.f / 108.f;
    }
  }

  // two neighbors are finer
  if (numFinerNeighbors == 2) {
    VERTEXTOPO octVtxTopo = GetVtxTopo(finerPntIdx[0], finerPntIdx[1]);
    // two edge neighbors
    if (octVtxTopo == EDGE) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[0] || i == finerPntIdx[1])
          weights[i] = 2.f / 9.f;
        else if (GetVtxTopo(finerPntIdx[0], i) == DIAG ||
                 GetVtxTopo(finerPntIdx[1], i) == DIAG)
          weights[i] = 1.f / 9.f;
        else
          weights[i] = 1.f / 12.f;
      }
    }
    // two face diag neighbors
    if (octVtxTopo == FACEDIAG) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[0] || i == finerPntIdx[1])
          weights[i] = 4.f / 15.f;
        else if (GetVtxTopo(finerPntIdx[0], i) == DIAG ||
                 GetVtxTopo(finerPntIdx[1], i) == DIAG)
          weights[i] = 1.f / 12.f;
        else if (GetVtxTopo(finerPntIdx[0], i) == EDGE)
          weights[i] = 1.f / 20.f;
        else
          weights[i] = 1.f / 10.f;
      }
    }
    // two diag neighbors
    if (octVtxTopo == DIAG) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[0] || i == finerPntIdx[1])
          weights[i] = 2.f / 7.f;
        else
          weights[i] = 1.f / 14.f;
      }
    }
  }

  // three neighbors are finer
  if (numFinerNeighbors == 3) {
    unsigned int8 edgeNum = 0;
    unsigned int8 vtxInEdgeCount[3] = {0,0,0};
    for (uniform unsigned int8 i = 0; i < numFinerNeighbors; i++) {
      unsigned int8 nextIdx = modIdx(i+1,numFinerNeighbors);
      if (GetVtxTopo(finerPntIdx[i],finerPntIdx[nextIdx]) == EDGE){
        vtxInEdgeCount[i]++;
        vtxInEdgeCount[nextIdx]++;
        edgeNum++;
      }
    }

    if (edgeNum == 2) {
      unsigned int8 sharedEdgeIdx =
          (vtxInEdgeCount[0] == 2) ? 0 : ((vtxInEdgeCount[1] == 2) ? 1 : 2);
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[sharedEdgeIdx])
          weights[i] = 4.f / 27.f;
        else if (i == finerPntIdx[modIdx(sharedEdgeIdx + 1,numFinerNeighbors)] ||
                 i == finerPntIdx[modIdx(sharedEdgeIdx + 2,numFinerNeighbors)]) {
          weights[i] = 2.f / 9.f;
        } else if (i == finerPntIdx[0] ^ finerPntIdx[1] ^ finerPntIdx[2]) {
          weights[i] = 1.f / 18.f;
        } else if (GetVtxTopo(finerPntIdx[sharedEdgeIdx], i) == DIAG) {
          weights[i] = 11.f / 108.f;
        } else {
          weights[i] = 1.f / 12.f;
        }
      }
    }

    if (edgeNum == 1) {
      unsigned int8 offEdgeIdx = (vtxInEdgeCount[0] == 0) ? 0 : ((vtxInEdgeCount[1] == 0) ? 1 : 2); 
      unsigned int8 symEdgeIdx = finerPntIdx[0] ^ finerPntIdx[1] ^ finerPntIdx[2];

      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[offEdgeIdx]) {
          weights[i] = 4.f / 15.f;
        } else if (GetVtxTopo(finerPntIdx[offEdgeIdx], i) == DIAG) {
          weights[i] = 2.f / 9.f;
        } else if (i == symEdgeIdx) {
          weights[i] = 2.f / 27.f;
        } else if (GetVtxTopo(symEdgeIdx, i) == DIAG) {
          weights[i] = 26.f / 135.f;
        } else if (GetVtxTopo(finerPntIdx[offEdgeIdx], i) == EDGE) {
          weights[i] = 1.f / 20.f;
        } else {
          weights[i] = 13.f / 180.f;
        }
      }
    }

    if (edgeNum == 0) {
      unsigned int8 farVerticalIdx = finerPntIdx[0] ^ finerPntIdx[1] ^ finerPntIdx[2];
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[0] || i == finerPntIdx[1] || i == finerPntIdx[2])
          weights[i] = 8.f / 33.f;
        else if (i == farVerticalIdx)
          weights[i] = 1.f / 11.f;
        else if (GetVtxTopo(farVerticalIdx, i) == DIAG)
          weights[i] = 1.f / 44.f;
        else
          weights[i] = 7.f / 132.f;
      }
    }
  }

  if (numFinerNeighbors == 4) {
    unsigned int8 edgeNum           = 0;
    unsigned int8 faceDiagNum       = 0;
    unsigned int8 vtxSharedByEdgeCount[4] = {0, 0, 0, 0};  // calculate the edge number that a finer point is shared. 
    for (uniform unsigned int8 i = 0; i < numFinerNeighbors; i++) {
      for (uniform unsigned int8 j = i + 1; j < numFinerNeighbors; j++) {
        unsigned int8 nextIdx = modIdx(j,numFinerNeighbors);
        if (GetVtxTopo(finerPntIdx[i], finerPntIdx[nextIdx]) == EDGE) {
          vtxSharedByEdgeCount[i]++;
          vtxSharedByEdgeCount[nextIdx]++;
          edgeNum++;
        }
        if (GetVtxTopo(finerPntIdx[i], finerPntIdx[nextIdx]) == FACEDIAG)
          faceDiagNum++;
      }
    }

    // PRINT(vtxSharedByEdgeCount[0]);

    if (edgeNum == 4) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[0] || i == finerPntIdx[1] || i == finerPntIdx[2] ||
            i == finerPntIdx[3])
          weights[i] = 1.f / 6.f;
        else
          weights[i] = 1.f / 12.f;
      }
    }

    if (edgeNum == 2 && faceDiagNum == 2) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[0] || i == finerPntIdx[1] || i == finerPntIdx[2] ||
            i == finerPntIdx[3])
          weights[i] = 1.f / 5.f;
        else
          weights[i] = 1.f / 20.f;
      }
    }

    if (faceDiagNum == 6) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == finerPntIdx[0] || i == finerPntIdx[1] || i == finerPntIdx[2] ||
            i == finerPntIdx[3])
          weights[i] = 2.f / 9.f;
        else
          weights[i] = 1.f / 36.f;
      }
    }

    if (edgeNum == 3 && faceDiagNum == 2) {
      unsigned int8 vtxSharedBy1Edges[2], vtxSharedBy2Edges[2];
      unsigned int8 tmp1 = 0, tmp2 = 0;
      for (uniform unsigned int8 i = 0; i < numFinerNeighbors; i++) {
        if (vtxSharedByEdgeCount[i] == 1)
          vtxSharedBy1Edges[tmp1++] = finerPntIdx[i];
        if (vtxSharedByEdgeCount[i] == 2)
          vtxSharedBy2Edges[tmp2++] = finerPntIdx[i];
      }

      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == vtxSharedBy1Edges[0] || i == vtxSharedBy1Edges[1]) {
          weights[i] = 2.f / 9.f;
        } else if (i == vtxSharedBy2Edges[0] || i == vtxSharedBy2Edges[1]) {
          weights[i] = 4.f / 27.f;
        } else if (GetVtxTopo(i, vtxSharedBy2Edges[0]) == DIAG ||
                   GetVtxTopo(i, vtxSharedBy2Edges[1]) == DIAG) {
          weights[i] = 2.f / 27.f;
        } else {
          weights[i] = 1.f / 18.f;
        }
      }
    }

    if (edgeNum == 3 && faceDiagNum == 3) {
      unsigned int8 vtxSharedBy1Edges[3], vtxSharedBy3Edges;
      unsigned int8 tmp1 = 0;
      for (uniform unsigned int8 i = 0; i < numFinerNeighbors; i++) {
        if (vtxSharedByEdgeCount[i] == 1)
          vtxSharedBy1Edges[tmp1++] = finerPntIdx[i];
        if (vtxSharedByEdgeCount[i] == 3)
          vtxSharedBy3Edges= finerPntIdx[i];
      }

      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == vtxSharedBy3Edges) {
          weights[i] = 2.f / 27.f;
        } else if (i == vtxSharedBy1Edges[0] || i == vtxSharedBy1Edges[1] || i == vtxSharedBy1Edges[2] ) {
          weights[i] = 2.f / 9.f;
        } else if (GetVtxTopo(i, vtxSharedBy3Edges) == DIAG) {
          weights[i] = 5.f / 54.f;
        } else {
          weights[i] = 1.f / 18.f;
        }
      }
    }

    if (edgeNum == 2 && faceDiagNum == 3) {
      unsigned int8 vtxSharedBy0Edges,vtxSharedBy1Edges[2], vtxSharedBy2Edges;
      unsigned int8 tmp1 = 0;
      for (uniform unsigned int8 i = 0; i < numFinerNeighbors; i++) {
        if (vtxSharedByEdgeCount[i] == 0)
          vtxSharedBy0Edges = finerPntIdx[i];
        if (vtxSharedByEdgeCount[i] == 1)
          vtxSharedBy1Edges[tmp1++] = finerPntIdx[i];
        if (vtxSharedByEdgeCount[i] == 2)
          vtxSharedBy2Edges= finerPntIdx[i];
      }

      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == vtxSharedBy0Edges) {
          weights[i] = 22.f / 89.f;
        } else if (i == vtxSharedBy1Edges[0] || i == vtxSharedBy1Edges[1]) {
          weights[i] = 52.f / 267.f;
        } else if (i == vtxSharedBy0Edges) {
          weights[i] = 14.f / 89.f;
        } else if (GetVtxTopo(i, vtxSharedBy1Edges[0]) == DIAG ||
                   GetVtxTopo(i, vtxSharedBy1Edges[1]) == DIAG) {
          weights[i] = 14.f / 267.f;
        } else if (GetVtxTopo(i, vtxSharedBy0Edges) == EDGE) {
          weights[i] = 5.f / 178.f;
        } else {
          weights[i] = 13.f / 178.f;
        }
      }
    }
  }

  if (numFinerNeighbors == 5) {
    unsigned int8 coarseEdgeNum           = 0;
    unsigned int8 vtxSharedByEdge[3] = {0, 0, 0};
    for (uniform unsigned int8 i = 0; i < numCoarseCtrlPnt; i++) {
      unsigned int8 nextIdx = modIdx(i + 1,numCoarseCtrlPnt);
      if (GetVtxTopo(coarsePntIdx[i], coarsePntIdx[nextIdx]) == EDGE) {
        vtxSharedByEdge[i]++;
        vtxSharedByEdge[nextIdx]++;
        coarseEdgeNum++;
      }
    }

    if(coarseEdgeNum == 2){
      unsigned int8 sharedVtx = (vtxSharedByEdge[0] == 2) ? 0 : ((vtxSharedByEdge[1] == 2) ? 1 : 2);
      for (uniform unsigned int8 i = 0; i < 8; i++) {
        if (i == coarsePntIdx[sharedVtx])
          weights[i] = 2.f / 27.f;
        else if (i == coarsePntIdx[modIdx(sharedVtx + 1, numCoarseCtrlPnt)] ||
                 i == coarsePntIdx[modIdx(sharedVtx + 2, numCoarseCtrlPnt)]) {
          weights[i] = 1.f / 18.f;
        } else if (i == coarsePntIdx[0] ^ coarsePntIdx[1] ^ coarsePntIdx[2]) {
          weights[i] = 2.f / 9.f;
        } else if (GetVtxTopo(coarsePntIdx[sharedVtx], i) == DIAG) {
          weights[i] = 5.f / 54.f;
        } else {
          weights[i] = 1.f / 6.f;
        }
      }
    }

    if(coarseEdgeNum == 1){
      unsigned int8 offEdgePntIdx = (vtxSharedByEdge[0] == 0) ? 0 : ((vtxSharedByEdge[1] == 0) ? 1 : 2); 
      unsigned int8 symEdgePnt = coarsePntIdx[0] ^ coarsePntIdx[1] ^ coarsePntIdx[2];

      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == coarsePntIdx[offEdgePntIdx]) {
          weights[i] = 1.f / 30.f;
        } else if (GetVtxTopo(coarsePntIdx[offEdgePntIdx], i) == DIAG) {
          weights[i] = 1.f / 18.f;
        } else if (i == symEdgePnt) {
          weights[i] = 4.f / 27.f;
        } else if (GetVtxTopo(symEdgePnt, i) == DIAG) {
          weights[i] = 7.f / 135.f;
        } else if (GetVtxTopo(coarsePntIdx[offEdgePntIdx], i) == EDGE) {
          weights[i] = 1.f / 5.f;
        } else {
          weights[i] = 7.f / 45.f;
        }
      }
    }

    if(coarseEdgeNum == 0){
      unsigned int8 farVerticalPnt = coarsePntIdx[0] ^ coarsePntIdx[1] ^ coarsePntIdx[2];
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == coarsePntIdx[0] || i == coarsePntIdx[1] || i == coarsePntIdx[2])
          weights[i] = 1.f / 33.f;
        else if (i == farVerticalPnt)
          weights[i] = 1.f / 11.f;
        else if (GetVtxTopo(farVerticalPnt, i) == DIAG)
          weights[i] = 5.f / 22.f;
        else
          weights[i] = 13.f / 66.f;
      }
    }
  }

  if(numFinerNeighbors == 6){
    VERTEXTOPO coarseVtxTopo = GetVtxTopo(coarsePntIdx[0], coarsePntIdx[1]);
    // two edge neighbors
    if (coarseVtxTopo == EDGE) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == coarsePntIdx[0] || i == coarsePntIdx[1])
          weights[i] = 1.f / 18.f;
        else if (GetVtxTopo(coarsePntIdx[0], i) == DIAG ||
                 GetVtxTopo(coarsePntIdx[1], i) == DIAG)
          weights[i] = 1.f / 9.f;
        else
          weights[i] = 1.f / 6.f;
      }
    }
    // two face diag neighbors
    if (coarseVtxTopo == FACEDIAG) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == coarsePntIdx[0] || i == coarsePntIdx[1])
          weights[i] = 1.f / 30.f;
        else if (GetVtxTopo(coarsePntIdx[0], i) == DIAG ||
                 GetVtxTopo(coarsePntIdx[1], i) == DIAG)
          weights[i] = 1.f / 6.f;
        else if (GetVtxTopo(coarsePntIdx[0], i) == EDGE)
          weights[i] = 1.f / 5.f;
        else
          weights[i] = 1.f / 10.f;
      }
    }
    // two diag neighbors
    if (coarseVtxTopo == DIAG) {
      for (unsigned int8 i = 0; i < 8; i++) {
        if (i == coarsePntIdx[0] || i == coarsePntIdx[1])
          weights[i] = 1.f / 26.f;
        else
          weights[i] = 2.f / 13.f;
      }
    }
  }

  if (numFinerNeighbors == 7) {
    for (unsigned int8 i = 0; i < 8; i++) {
      VERTEXTOPO vtxTopo = GetVtxTopo(coarsePntIdx[0], i);
      if (vtxTopo == IDENTIFY)
        weights[i] = 1.f / 27.f;
      if (vtxTopo == EDGE)
        weights[i] = 1.f / 6.f;
      if (vtxTopo == FACEDIAG)
        weights[i] = 1.f / 9.f;
      if (vtxTopo == DIAG)
        weights[i] = 7.f / 54.f;
    }
  }

  wSum = wSum + weights[0] * ctrlPntsValue[0] + weights[1] * ctrlPntsValue[1] +
         weights[2] * ctrlPntsValue[2] + weights[3] * ctrlPntsValue[3] +
         weights[4] * ctrlPntsValue[4] + weights[5] * ctrlPntsValue[5] +
         weights[6] * ctrlPntsValue[6] + weights[7] * ctrlPntsValue[7];
 
  return wSum;
}

